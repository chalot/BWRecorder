/*****************************************************************************
* Model: bwgpsrecorder.qm
* File:  qmcode/qupgrade.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/3/12) ................................................................*/
#include <qp_port.h>
#include <qevents.h>
#include <bsp.h>
#include <upgrade.h>
#include <protocol.h>
#include <utility.h>
#include <can.h>
#include "type.h"

Q_DEFINE_THIS_MODULE("qupgrade.c")


extern u8 g_bCANRecvCtrl; //控制CAN中断停止接收

#define DETECTING_KEPT_AMOUNT  4 //检测累计次数：100次，共用时1S


/* Active object class -----------------------------------------------------*/
/* @(/1/11) ................................................................*/
typedef struct QUpgradeTag {
/* protected: */
    QActive super;

/* private: */
    uint8_t m_State;
    uint8_t m_bUpgFileExisted;
    uint16_t m_CurBlockId;
    uint16_t m_BlocksAmount;
    QTimeEvt m_Timer;
    uint16_t m_detectTimes;
} QUpgrade;

/* protected: */
static QState QUpgrade_initial(QUpgrade * const me, QEvt const * const e);
static QState QUpgrade_Detecting(QUpgrade * const me, QEvt const * const e);
static QState QUpgrade_checking(QUpgrade * const me, QEvt const * const e);
static QState QUpgrade_upgrading(QUpgrade * const me, QEvt const * const e);
static QState QUpgrade_idle(QUpgrade * const me, QEvt const * const e);



/* Local objects -----------------------------------------------------------*/
static QUpgrade l_Upgrade; /* the single instance of the Table active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_Upgrade = &l_Upgrade.super; /* "opaque" AO pointer */

/*..........................................................................*/
/* @(/1/26) ................................................................*/
void QUpgrade_ctor(void) {
    QUpgrade *me = &l_Upgrade;
    QActive_ctor(&me->super, Q_STATE_CAST(&QUpgrade_initial));
    QTimeEvt_ctor(&me->m_Timer, Q_TIMEOUT_SIG);
}
/* @(/1/11) ................................................................*/
/* @(/1/11/6) ..............................................................*/
/* @(/1/11/6/0) */
static QState QUpgrade_initial(QUpgrade * const me, QEvt const * const e) {
    me->m_detectTimes = 0;
    me->m_bUpgFileExisted = 0;

     //初始化时，先广播一次ACC状态
    me->m_State = UPG_SD_Detect();
    return Q_TRAN(&QUpgrade_idle);
}
/* @(/1/11/6/1) ............................................................*/
static QState QUpgrade_Detecting(QUpgrade * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/11/6/1) */
        case Q_ENTRY_SIG: {
            QTimeEvt_postIn(&me->m_Timer, &me->super, BSP_TICKS_PER_SEC >> 1);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/11/6/1) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/11/6/1/0) */
        case Q_TIMEOUT_SIG: {
            u8 curState = UPG_SD_Detect();
            me->m_detectTimes++;
            /* @(/1/11/6/1/0/0) */
            if (curState != me->m_State) {
                //状态发生变化，重新开始检测
                me->m_detectTimes = 0;
                status_ = Q_TRAN(&QUpgrade_Detecting);
            }
            /* @(/1/11/6/1/0/1) */
            else {
                me->m_State = curState;
                /* @(/1/11/6/1/0/1/0) */
                if (me->m_detectTimes >= DETECTING_KEPT_AMOUNT) {
                    #if 0
                    static const QEvent sdcard_on_Evt = {SDCARD_ON_SIG, 0};
                    static const QEvent sdcard_off_Evt = {SDCARD_OFF_SIG, 0};

                    if(me->m_State == 0)
                    {
                        QACTIVE_POST(me, (QEvt*)&sdcard_on_Evt, (void*)0);
                    }
                    else
                    {
                        QACTIVE_POST(me, (QEvt*)&sdcard_off_Evt, (void*)0);
                    }
                    #endif
                    /* @(/1/11/6/1/0/1/0/0) */
                    if (0 == me->m_State) {
                        status_ = Q_TRAN(&QUpgrade_idle);
                    }
                    /* @(/1/11/6/1/0/1/0/1) */
                    else {
                        status_ = Q_TRAN(&QUpgrade_checking);
                    }
                }
                /* @(/1/11/6/1/0/1/1) */
                else {
                    status_ = Q_TRAN(&QUpgrade_Detecting);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/1/11/6/2) ............................................................*/
static QState QUpgrade_checking(QUpgrade * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/11/6/2) */
        case Q_ENTRY_SIG: {
            static const QEvt upg_evt = {SYS_UPGRAGE_SIG, 0};

            QTimeEvt_postIn(&me->m_Timer, &me->super, BSP_TICKS_PER_SEC << 3);

            if(!UPG_SD_Init())
            {
            //    UPG_ReportSDCardState(SD_STATUS_INITFAIL);
            }
            else
            {
                me->m_bUpgFileExisted = Upg_CheckUpgradeFileExisted();
                if(1 == me->m_bUpgFileExisted)
                {

                    if(UPG_CheckUpgFileValidation())
                    {
                        static const QEvt start_evt = {UPG_START_SIG, 0};

                        //广播开始升级消息，其他状态机收到此消息后必须停止所有工作
            //            QF_publish(&start_evt, me);

            //            QACTIVE_POST(me, (QEvt*)&start_evt, (void*)0);
                    }
                }
            }


            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/11/6/2) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/11/6/2/0) */
        case UPG_START_SIG: {
            me->m_BlocksAmount = UPG_GetBlocksAmount();
            me->m_CurBlockId = 0;
            CAN_RecieveDisable();
            status_ = Q_TRAN(&QUpgrade_upgrading);
            break;
        }
        /* @(/1/11/6/2/1) */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&QUpgrade_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/1/11/6/3) ............................................................*/
static QState QUpgrade_upgrading(QUpgrade * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/11/6/3) */
        case Q_ENTRY_SIG: {
            static const QEvent ok_Evt = {UPG_OK_SIG, 0};
            static const QEvent err_Evt = {UPG_ERR_SIG, 0};

            BOOL ret = UPG_TransferBlocks2Flash(me->m_CurBlockId);
            if(ret)
            {
            //    QACTIVE_POST(me, (QEvt*)&ok_Evt, (void*)0);
            }
            else
            {
             //   QACTIVE_POST(me, (QEvt*)&err_Evt, (void*)0);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/11/6/3/0) */
        case UPG_OK_SIG: {
            me->m_CurBlockId++;
            /* @(/1/11/6/3/0/0) */
            if (me->m_CurBlockId < me->m_BlocksAmount) {
                status_ = Q_TRAN(&QUpgrade_upgrading);
            }
            /* @(/1/11/6/3/0/1) */
            else {
                UPD_MarkFileReady();
                status_ = Q_HANDLED();
            }
            break;
        }
        /* @(/1/11/6/3/1) */
        case UPG_ERR_SIG: {
            CAN_RECIEVE_ENABLE();///CAN中断使能接收
            status_ = Q_TRAN(&QUpgrade_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/1/11/6/4) ............................................................*/
static QState QUpgrade_idle(QUpgrade * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/11/6/4) */
        case Q_ENTRY_SIG: {
            QTimeEvt_postIn(&me->m_Timer, &me->super, BSP_TICKS_PER_SEC * 10/* * 60*/);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/11/6/4) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/11/6/4/0) */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&QUpgrade_Detecting);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

