/*****************************************************************************
* Model: bwgpsrecorder.qm
* File:  qmcode/qkey.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/3/17) ................................................................*/
#include "qp_port.h"
#include "qevents.h"
#include "bsp.h"
#include "type.h"
#include "utility.h"
#include "error.h"
#include "key.h"
#include "qactiveobjs.h"
#include "qevt.h"


Q_DEFINE_THIS_MODULE("qkey.c")

#define DETECTING_KEPT_AMOUNT  5 //检测累计次数：5次，共用时50ms
#define TIMEOUT_DETECTING      (BSP_TICKS_PER_SEC) //检测周期,10ms

/* Active object class -----------------------------------------------------*/
/* @(/1/20) ................................................................*/
typedef struct QKeyTag {
/* protected: */
    QActive super;

/* private: */
    uint8_t m_detectTimes;
    uint16_t m_val;
    QTimeEvt m_Timer;
} QKey;

/* protected: */
static QState QKey_initial(QKey * const me, QEvt const * const e);
static QState QKey_idle(QKey * const me, QEvt const * const e);
static QState QKey_busy(QKey * const me, QEvt const * const e);



/* Local objects -----------------------------------------------------------*/
static QKey l_QKey; /* the single instance of the Table active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_Key = &l_QKey.super; /* "opaque" AO pointer */

/*..........................................................................*/
/* @(/1/38) ................................................................*/
void QKey_ctor(void) {
    QKey *me = &l_QKey;
    QActive_ctor(&me->super, Q_STATE_CAST(&QKey_initial));
}
/* @(/1/20) ................................................................*/
/* @(/1/20/3) ..............................................................*/
/* @(/1/20/3/0) */
static QState QKey_initial(QKey * const me, QEvt const * const e) {
    QS_SIG_DICTIONARY(KEY_OK_SIG, (void*)0);
    QS_SIG_DICTIONARY(KEY_UP_SIG, (void*)0);
    QS_SIG_DICTIONARY(KEY_DOWN_SIG, (void*)0);
    QS_SIG_DICTIONARY(KEY_MENU_SIG, (void*)0);

    QS_SIG_DICTIONARY(Q_TIMEOUT_SIG, me);
    return Q_TRAN(&QKey_idle);
}
/* @(/1/20/3/1) ............................................................*/
static QState QKey_idle(QKey * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/20/3/1/0) */
        case ACC_ONCHANGE_SIG: {
            status_ = Q_TRAN(&QKey_busy);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/1/20/3/2) ............................................................*/
static QState QKey_busy(QKey * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/20/3/2) */
        case Q_ENTRY_SIG: {
            me->m_detectTimes = 0;

            //保持1S
            QTimeEvt_postEvery(&me->m_Timer, &me->super, TIMEOUT_DETECTING);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/20/3/2) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/20/3/2/0) */
        case Q_TIMEOUT_SIG: {
            me->m_val += Key_GetADCValue(); ///取当前采样值
            me->m_detectTimes++;
            me->m_val >>= 1; ///与新值取平均
            /* @(/1/20/3/2/0/0) */
            if (me->m_detectTimes >= DETECTING_KEPT_AMOUNT) {
                static const QEvent key_ok_Evt = {KEY_OK_SIG, 0};
                static const QEvent key_up_Evt = {KEY_UP_SIG, 0};
                static const QEvent key_down_Evt = {KEY_DOWN_SIG, 0};
                static const QEvent key_menu_Evt = {KEY_MENU_SIG, 0};

                //TaskEvt *pe;
                eKEY eKey;

                eKey = Key_GetCode(me->m_val);
                switch(eKey)
                {
                    case KEY_OK:
                        QACTIVE_POST(AO_LCD, (QEvt*)&key_ok_Evt, me);    break;
                    case KEY_UP:
                        QACTIVE_POST(AO_LCD, (QEvt*)&key_up_Evt, me);    break;
                    case KEY_DOWN:
                        QACTIVE_POST(AO_LCD, (QEvt*)&key_down_Evt, me);    break;
                    case KEY_MENU:
                        QACTIVE_POST(AO_LCD, (QEvt*)&key_menu_Evt, me);    break;
                    default:
                        TRACE_(QS_USER, NULL, "unknown key msg.");    break;
                }

                /*
                //上报服务器车辆状态
                //1.  00为停车，FE为充电启动；FF为钥匙启动；
                pe = Q_NEW(TaskEvt, NEW_TASKSENDREQ_SIG);
                pe->cmd = EVS15_CMD_START_STOP_RPT; //命令字
                pe->sequence = GeneratePacketSequenceNumber();
                pe->ret = (me->m_state == 0) ? STATE_ACCON : STATE_STOP;
                QACTIVE_POST(AO_Gprs, (QEvt*)pe, (void*)0);
                */
                status_ = Q_TRAN(&QKey_idle);
            }
            /* @(/1/20/3/2/0/1) */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

