/*****************************************************************************
* Model: bwgpsrecorder.qm
* File:  qmcode/qgprs.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/3/9) .................................................................*/
#include <qp_port.h>
#include <qevents.h>
#include <bsp.h>
#include "type.h"
#include <protocol.h>
#include <utility.h>
#include <error.h>
#include <gprs.h>
#include <stm32_gpio.h>
#include <trace.h>

Q_DEFINE_THIS_MODULE("qgprs.c")


#define TASK_QUEUE_SIZE  10  //任务队列大小
#define TASK_AMOUNT_MAX  10  //待发送任务数


/* 外部对象 ------------------------------------------------------------------*/

//临时发送缓区
#define FRAME_BUF_SIZE   1024

//  外部函数 -------------------------------------------------------------------
extern void GPRS_SendTCPIPPrefix(u16 dataLen);/* 发送TCPIP前缀 */
extern void GPRS_FillinTCPIPData(u8 *pDataBuf, u16 dataLen);/* 填充待发送数据内容 */

extern void GPRS_doInit(u8 initStep); //执行初始化序列
extern void GPRS_doConnect(u8 connectStep);//执行连接序列
extern void GPRS_doRegister();//执行网络注册序列
/* 组织待发送数据内容 */
extern u16 GPRS_FormRawFrame( u8 *pSendBuf,u16 m_cmd,u16 m_sequence,
                                void* m_address, u16 m_dataSize, u16 m_offset);

extern void Protocol_TCPIPData_Process(u8 *pMsg, u16 msgLen);
extern u16 Protocol_FormRawFrame(TaskEvt *pTaskEvt, u8 *pBuf, u16 bufSize);
extern void Protocol_ServerGeneralAckProc(tMsg_S_GeneralAck *pSAck);



#define POWERON  1
#define POWEROFF 0


#define TIMEOUT_LEDFLASH       (BSP_TICKS_PER_SEC * 3) //LED指示灯闪烁周期
#define TIMEOUT_ATACK          (BSP_TICKS_PER_SEC * 5) //普通AT指令响应超时:
#define TIMEOUT_ATTIPS         (BSP_TICKS_PER_SEC * 10) //发送数据等待‘>’超时
#define TIMEOUT_ATSENDRET      (BSP_TICKS_PER_SEC * 5) //发送数据结果超时
#define TIMEOUT_ATREG          (BSP_TICKS_PER_SEC * 5) //等待网络注册超时
#define TIMEOUT_ATCONNECT      (BSP_TICKS_PER_SEC * 5) //等待网络注册超时


#define TIMEOUT_PWRON_TICKS        BSP_TICKS_PER_SEC
#define TIMEOUT_PWRONBEFORE_TICKS  BSP_TICKS_PER_SEC
#define TIMEOUT_PWRONAFTER_TICKS   BSP_TICKS_PER_SEC
#define TIMEOUT_RESETBEFORE_TICKS  (BSP_TICKS_PER_SEC << 3) //复位关电时间，8s
#define TIMEOUT_RESETAFTER_TICKS   BSP_TICKS_PER_SEC

#define TIMEOUT_LED_CONNECTED      (BSP_TICKS_PER_SEC * 3)
#define TIMEOUT_LED_CONNECTING     (BSP_TICKS_PER_SEC)
#define TIMEOUT_PING               (BSP_TICKS_PER_SEC * 10)
#define TIMEOUT_AT_DATAQUERYRET    (BSP_TICKS_PER_SEC * 5)


#define TIMEOUT_RETRIEVE           (BSP_TICKS_PER_SEC >> 2)
#define TIMEOUT_DATAQUERY          (BSP_TICKS_PER_SEC)

#define INIT_TRY_MAXTIMES       20  //初始化尝试次数
#define REGISTER_TRY_MAXTIMES   20  //初始化尝试次数
#define CONNECT_ERROR_MAXTIMES  20  // 尝试连接失败累计重连次数



/* local objects -----------------------------------------------------------*/
/* @(/1/8) .................................................................*/
typedef struct QGprsTag {
/* protected: */
    QActive super;

/* private: */
    uint8_t m_ACCState;
    QTimeEvt m_LEDTimer;
    uint8_t m_ATStep;
    QTimeEvt m_Timer;
    QTimeEvt m_retrieveTimer;
    QEQueue m_requestQueue;
    QEvt const * m_requestQSto[TASK_QUEUE_SIZE];
    uint16_t m_cmd;
    uint16_t m_sequence;
    void* m_address;
    uint16_t m_dataSize;
    uint16_t m_offset;
    u8* m_pSendBuf;
    uint16_t m_SendDataLen;
    uint8_t m_initStep;
    uint8_t m_connectStep;
    uint8_t m_TryTimes;
    uint8_t m_NetState;

/* public: */
    uint8_t m_ATErrorTimes;

/* private: */
    uint8_t m_sendBuf[FRAME_BUF_SIZE];
    QTimeEvt m_PingTimer;
    uint8_t m_deferedDataReady;
    uint8_t m_bSleepReq;
} QGprs;

/* protected: */
static QState QGprs_initial(QGprs * const me, QEvt const * const e);
static QState QGprs_serving(QGprs * const me, QEvt const * const e);
static QState QGprs_startup(QGprs * const me, QEvt const * const e);
static QState QGprs_power_on(QGprs * const me, QEvt const * const e);
static QState QGprs_start_finished(QGprs * const me, QEvt const * const e);
static QState QGprs_start_delay(QGprs * const me, QEvt const * const e);
static QState QGprs_polling(QGprs * const me, QEvt const * const e);
static QState QGprs_registering(QGprs * const me, QEvt const * const e);
static QState QGprs_initialing(QGprs * const me, QEvt const * const e);
static QState QGprs_initialing_stepinto(QGprs * const me, QEvt const * const e);
static QState QGprs_powerNormalMode(QGprs * const me, QEvt const * const e);
static QState QGprs_disconnected(QGprs * const me, QEvt const * const e);
static QState QGprs_connecting(QGprs * const me, QEvt const * const e);
static QState QGprs_connected(QGprs * const me, QEvt const * const e);
static QState QGprs_TcpSending(QGprs * const me, QEvt const * const e);
static QState QGprs_WaitFillData(QGprs * const me, QEvt const * const e);
static QState QGprs_WaitRet(QGprs * const me, QEvt const * const e);
static QState QGprs_Idle(QGprs * const me, QEvt const * const e);
static QState QGprs_PhoneCalling(QGprs * const me, QEvt const * const e);
static QState QGprs_SMSHandling(QGprs * const me, QEvt const * const e);
static QState QGprs_DataQuering(QGprs * const me, QEvt const * const e);
static QState QGprs_sleepRequest(QGprs * const me, QEvt const * const e);
static QState QGprs_reseting(QGprs * const me, QEvt const * const e);
static QState QGprs_powerSaveMode(QGprs * const me, QEvt const * const e);
static QState QGprs_sleep(QGprs * const me, QEvt const * const e);
static QState QGprs_sleep_SMSHandling(QGprs * const me, QEvt const * const e);
static QState QGprs_sleep_PhoneCalling(QGprs * const me, QEvt const * const e);



/* Global objects ----------------------------------------------------------*/
static QGprs l_Gprs;     /* the single instance of the Gprs active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_Gprs = &l_Gprs.super; /* "opaque" AO pointer */


/* Active object definition ================================================*/
/* @(/1/21) ................................................................*/
void QGprs_ctor(void) {
    QGprs *me = &l_Gprs;
    QActive_ctor(&me->super, Q_STATE_CAST(&QGprs_initial));
    QTimeEvt_ctor(&me->m_Timer, Q_TIMEOUT_SIG);
    QTimeEvt_ctor(&me->m_LEDTimer, GPRS_LED_TIMEOUT_SIG);
    QTimeEvt_ctor(&me->m_retrieveTimer, GPRS_RETRIEVE_TIMEOUT_SIG);
    QTimeEvt_ctor(&me->m_PingTimer, GPRS_PING_TIMEOUT_SIG);
    QTimeEvt_ctor(&me->m_retrieveTimer, GPRS_RETRIEVE_TIMEOUT_SIG);
}
/* @(/1/8) .................................................................*/
/* @(/1/8/23) ..............................................................*/
/* @(/1/8/23/0) */
static QState QGprs_initial(QGprs * const me, QEvt const * const e) {
    /* 状态消息 */
    QS_FUN_DICTIONARY(&QGprs_initialing);
    QS_FUN_DICTIONARY(&QGprs_initialing_stepinto);
    QS_FUN_DICTIONARY(&QGprs_polling);
    QS_FUN_DICTIONARY(&QGprs_startup);
    QS_FUN_DICTIONARY(&QGprs_power_on);
    QS_FUN_DICTIONARY(&QGprs_start_delay);
    QS_FUN_DICTIONARY(&QGprs_start_finished);
    QS_FUN_DICTIONARY(&QGprs_reseting);
    QS_FUN_DICTIONARY(&QGprs_initialing);
    QS_FUN_DICTIONARY(&QGprs_registering);
    QS_FUN_DICTIONARY(&QGprs_powerNormalMode);
    QS_FUN_DICTIONARY(&QGprs_connected);
    QS_FUN_DICTIONARY(&QGprs_TcpSending);
    QS_FUN_DICTIONARY(&QGprs_WaitFillData);
    QS_FUN_DICTIONARY(&QGprs_WaitRet);
    QS_FUN_DICTIONARY(&QGprs_Idle);
    QS_FUN_DICTIONARY(&QGprs_PhoneCalling);
    QS_FUN_DICTIONARY(&QGprs_SMSHandling);
    QS_FUN_DICTIONARY(&QGprs_connecting);
    QS_FUN_DICTIONARY(&QGprs_powerSaveMode);
    QS_FUN_DICTIONARY(&QGprs_sleepRequest);
    QS_FUN_DICTIONARY(&QGprs_sleep);
    QS_FUN_DICTIONARY(&QGprs_registering);


    QS_SIG_DICTIONARY(AT_OK_SIG, me);
    QS_SIG_DICTIONARY(AT_REGGED_SIG, me);
    QS_SIG_DICTIONARY(AT_PINREADY_SIG, me);
    QS_SIG_DICTIONARY(AT_NETREGGED_SIG, me);
    QS_SIG_DICTIONARY(AT_NETDISREG_SIG, me);
    QS_SIG_DICTIONARY(AT_CSQ_SIG, me);
    QS_SIG_DICTIONARY(AT_CONNECTED_SIG, me);
    QS_SIG_DICTIONARY(AT_DISCONNECTED_SIG, me);
    //QS_SIG_DICTIONARY(AT_DATAREADY_SIG, me);
    QS_SIG_DICTIONARY(AT_SENDREADY_SIG, me);
    QS_SIG_DICTIONARY(AT_SENDFILLDATA_SIG, me);
    QS_SIG_DICTIONARY(AT_ERROR_SIG, me);
    QS_SIG_DICTIONARY(AT_CMSERROR_SIG, me);
    QS_SIG_DICTIONARY(AT_CMEERROR_SIG, me);
    QS_SIG_DICTIONARY(AT_SENDERROR_SIG, me);
    QS_SIG_DICTIONARY(AT_FILLDATATIP_SIG, me);
    QS_SIG_DICTIONARY(AT_SENDOK_SIG, me);
    QS_SIG_DICTIONARY(GPRS_COMMINGMSG_SIG, me);

    /* AO内部消息 */
    QS_SIG_DICTIONARY(Q_TIMEOUT_SIG, me);
    QS_SIG_DICTIONARY(GPRS_SENDREQ_SIG, me);
    //QS_SIG_DICTIONARY(GPRS_LED_TIMEOUT_SIG, me);
    //QS_SIG_DICTIONARY(GPRS_RETRIEVE_TIMEOUT_SIG, me);
    QS_SIG_DICTIONARY(NEW_TASKSENDREQ_SIG, me);
    QS_SIG_DICTIONARY(GPRS_SLEEPREQ_TIMEOUT_SIG, me);
    QS_SIG_DICTIONARY(GPRS_PHONECALL_HANDLED_SIG, me);
    QS_SIG_DICTIONARY(GPRS_SMS_HANDLED_SIG, me);
    QS_SIG_DICTIONARY(GPRS_COMMINGCALL_SIG, me);
    QS_SIG_DICTIONARY(GPRS_COMMINGSMS_SIG, me);

    QActive_subscribe((QActive *)me, ACC_ON_SIG);
    QActive_subscribe((QActive *)me, ACC_OFF_SIG);
    QActive_subscribe(&me->super, WAKEUP_REQ_SIG);
    QActive_subscribe(&me->super, SLEEP_REQ_SIG);

    //模块内部初始化
    GPRS_Init();

    me->m_ACCState = POWEROFF;
    me->m_NetState = NET_STATE_UNKOWN;
    GPRS_SetNetState(NET_STATE_UNKOWN);

    //网络指示灯关闭
    GPRS_LED_OFF();

    return Q_TRAN(&QGprs_serving);
}
/* @(/1/8/23/1) ............................................................*/
static QState QGprs_serving(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&QGprs_startup);
            break;
        }
        /* @(/1/8/23/1/1) */
        case ACC_ON_SIG: {
            me->m_ACCState = POWERON;
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/2) */
        case ACC_OFF_SIG: {
            me->m_ACCState = POWEROFF;
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/3) */
        case NEW_TASKSENDREQ_SIG: {
            if (QEQueue_getNFree(&me->m_requestQueue) > 0) {
                /* defer the request */
                QActive_defer((QActive *)me, &me->m_requestQueue, e);
                TRACE_(GPRS_STAT, &me->super, "Request cmd: %x deferred;\n",
                       (int)((TaskEvt const *)e)->cmd);
            }
            else {
                TRACE_(GPRS_STAT, &me->super, "Request #%d IGNORED;\n", (int)((TaskEvt const *)e)->cmd);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/4) */
        case SIMCARD_ONCHANGE_SIG: {
            #if 0
            //SIM卡检测
            if(0 == GPIO_ReadInputDataBit(GPIOC,GPIOC_SIM_DET_))
            {
                ClearErrType(NET_CLASS, NET_FAULT_SIMCARD);    //SIM卡插入
            }
            else
            {
                SetErrType(NET_CLASS, NET_FAULT_SIMCARD);    //SIM卡拔出
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/5) */
        case SLEEP_REQ_SIG: {
            TRACE_(QS_USER, NULL, "[GPRS] ----- PowerMgr: SLEEP, but defered. -----");
            me->m_bSleepReq = 1;
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/6) ..........................................................*/
static QState QGprs_startup(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/6/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&QGprs_power_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_serving);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/6/1) ........................................................*/
static QState QGprs_power_on(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/6/1) */
        case Q_ENTRY_SIG: {
            //模块上电
            GPIO_SetBits(GPIOA,GPIOA_CDMA_CTRL_);
            /* TERMON 高电平 */
            GPIO_ResetBits(GPIOA, GPIOA_GPRS_PWRKEY_);

            //保持1S
            QTimeEvt_postIn(&me->m_Timer, &me->super, TIMEOUT_PWRON_TICKS);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/6/1) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/6/1/0) */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&QGprs_start_delay);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_startup);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/6/2) ........................................................*/
static QState QGprs_start_finished(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/6/2) */
        case Q_ENTRY_SIG: {
            /* TERMON 高电平 */
            GPIO_ResetBits(GPIOA, GPIOA_GPRS_PWRKEY_);
            /* 已开机，稍延时待稳定后执行AT */
            QTimeEvt_postIn(&me->m_Timer, &me->super, TIMEOUT_PWRONAFTER_TICKS);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/6/2) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/6/2/0) */
        case Q_TIMEOUT_SIG: {
            //串口IO重新初始化
            GPRS_UartReconfigure();
            status_ = Q_TRAN(&QGprs_polling);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_startup);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/6/3) ........................................................*/
static QState QGprs_start_delay(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/6/3) */
        case Q_ENTRY_SIG: {
            //先管脚拉低
            GPIO_SetBits(GPIOA, GPIOA_GPRS_PWRKEY_);
            //低电平拉低1000ms
            QTimeEvt_postIn(&me->m_Timer, &me->super, TIMEOUT_PWRONBEFORE_TICKS);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/6/3) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/6/3/0) */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&QGprs_start_finished);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_startup);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7) ..........................................................*/
static QState QGprs_polling(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7) */
        case Q_ENTRY_SIG: {
            QTimeEvt_postEvery(&me->m_retrieveTimer, &me->super, TIMEOUT_RETRIEVE);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_retrieveTimer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&QGprs_initialing);
            break;
        }
        /* @(/1/8/23/1/7/1) */
        case GPRS_RETRIEVE_TIMEOUT_SIG: {
            //接收串口提取
            GPRS_doRetrieveFrame(0, 0);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/2) */
        case AT_DATAREADY_SIG: {
            //延迟消息到达提取
            me->m_deferedDataReady ++;

            #if 0
            ATMsgEvt* pe = (ATMsgEvt*)e;

            //接收串口提取
            GPRS_doRetrieveFrame(pe->begin, pe->end);

            #endif

            //接收串口提取
            //GPRS_doRetrieveFrame(0, 0);

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_serving);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/3) ........................................................*/
static QState QGprs_registering(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/3) */
        case Q_ENTRY_SIG: {
            //执行注册网络AT指令
            GPRS_doRegister();
            QTimeEvt_postIn(&me->m_Timer, &me->super, TIMEOUT_ATREG);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/3) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/3/0) */
        case AT_OK_SIG: {
            if(GPRS_GetRegState())
            {
                me->m_NetState = NET_STATE_REGISTED;
                GPRS_SetNetState(NET_STATE_REGISTED);
            }
            /* @(/1/8/23/1/7/3/0/0) */
            if (GPRS_GetRegState() == 0) {
                status_ = Q_HANDLED();
            }
            /* @(/1/8/23/1/7/3/0/1) */
            else {
                status_ = Q_TRAN(&QGprs_powerNormalMode);
            }
            break;
        }
        /* @(/1/8/23/1/7/3/1) */
        case Q_TIMEOUT_SIG: {
            me->m_TryTimes++;
            /* @(/1/8/23/1/7/3/1/0) */
            if (me->m_TryTimes < REGISTER_TRY_MAXTIMES) {
                status_ = Q_TRAN(&QGprs_registering);
            }
            /* @(/1/8/23/1/7/3/1/1) */
            else {
                TRACE_(QS_USER, NULL, "*** [GPRS] Regging timeout, repower gprs");
                status_ = Q_TRAN(&QGprs_reseting);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_polling);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/4) ........................................................*/
static QState QGprs_initialing(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/4) */
        case Q_ENTRY_SIG: {
            me->m_ATStep = 0;
            me->m_TryTimes = 0;
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/4/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&QGprs_initialing_stepinto);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_polling);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/4/1) ......................................................*/
static QState QGprs_initialing_stepinto(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/4/1) */
        case Q_ENTRY_SIG: {
            //执行初始化序列
            GPRS_doInit(me->m_ATStep);
            QTimeEvt_postIn(&me->m_Timer, &me->super, TIMEOUT_ATACK);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/4/1) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/4/1/0) */
        case Q_TIMEOUT_SIG: {
            me->m_TryTimes ++;
            /* @(/1/8/23/1/7/4/1/0/0) */
            if (me->m_TryTimes < INIT_TRY_MAXTIMES) {
                status_ = Q_TRAN(&QGprs_initialing_stepinto);
            }
            /* @(/1/8/23/1/7/4/1/0/1) */
            else {
                TRACE_(QS_USER, NULL, "*** [GPRS] init failed, repower gprs");
                status_ = Q_TRAN(&QGprs_reseting);
            }
            break;
        }
        /* @(/1/8/23/1/7/4/1/1) */
        case AT_OK_SIG: {
            /* @(/1/8/23/1/7/4/1/1/0) */
            if (0 == GPRS_CheckCmd_IsAttaching(me->m_ATStep)) {
                me->m_ATStep ++;
                /* @(/1/8/23/1/7/4/1/1/0/0) */
                if (me->m_ATStep < INIT_STEPS_AMOUNT) {
                    status_ = Q_TRAN(&QGprs_initialing_stepinto);
                }
                /* @(/1/8/23/1/7/4/1/1/0/1) */
                else {
                    me->m_TryTimes = 0;
                    status_ = Q_TRAN(&QGprs_registering);
                }
            }
            /* @(/1/8/23/1/7/4/1/1/1) */
            else {
                /* @(/1/8/23/1/7/4/1/1/1/0) */
                if (1 == GPRS_GetAttachState()) {
                    me->m_ATStep ++;
                    status_ = Q_TRAN(&QGprs_initialing_stepinto);
                }
                /* @(/1/8/23/1/7/4/1/1/1/1) */
                else {
                    status_ = Q_HANDLED();
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_initialing);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5) ........................................................*/
static QState QGprs_powerNormalMode(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5) */
        case Q_ENTRY_SIG: {
            //复位AT执行序列
            me->m_ATStep = 0;
            //启动LED闪烁定时器
            QTimeEvt_postEvery(&me->m_LEDTimer, &me->super, TIMEOUT_LED_CONNECTING);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            QTimeEvt_disarm(&me->m_LEDTimer);
            //关闭状态灯
            GPRS_LED_OFF();
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&QGprs_disconnected);
            break;
        }
        /* @(/1/8/23/1/7/5/1) */
        case ACC_OFF_SIG: {
            me->m_ACCState = POWEROFF;
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/2) */
        case GPRS_LED_TIMEOUT_SIG: {
            //static QEvt const query_Evt = {AT_DATAQUERY_SIG, 0, 0};
            //QACTIVE_POST(me, (QEvt*)&query_Evt, NULL);
            //QACTIVE_POST(me, (QEvt*)Q_NEW(QEvt, AT_DATAQUERY_SIG), (void*)0);
            //LED指示灯闪烁
            GPRS_FLASH_LED();

            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/3) */
        case GPRS_PING_TIMEOUT_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_polling);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/4) ......................................................*/
static QState QGprs_disconnected(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/4) */
        case Q_ENTRY_SIG: {
            me->m_ATErrorTimes = 0;
            me->m_ATStep = 0;
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/4/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&QGprs_connecting);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_powerNormalMode);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/4/1) ....................................................*/
static QState QGprs_connecting(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/4/1) */
        case Q_ENTRY_SIG: {
            //执行连接AT序列
            GPRS_doConnect(me->m_ATStep);
            QTimeEvt_postIn(&me->m_Timer, &me->super, TIMEOUT_ATCONNECT);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/4/1) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            QTimeEvt_disarm(&me->m_LEDTimer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/4/1/0) */
        case AT_OK_SIG: {
            me->m_ATStep ++;
            /* @(/1/8/23/1/7/5/4/1/0/0) */
            if (me->m_ATStep < (CONNECT_STEPS_AMOUNT)) {
                status_ = Q_TRAN(&QGprs_connecting);
            }
            /* @(/1/8/23/1/7/5/4/1/0/1) */
            else {
                status_ = Q_TRAN(&QGprs_connected);
            }
            break;
        }
        /* @(/1/8/23/1/7/5/4/1/1) */
        case AT_ERROR_SIG: {
            me->m_ATErrorTimes ++;
            me->m_ATStep ++;
            /* @(/1/8/23/1/7/5/4/1/1/0) */
            if (me->m_ATStep < (CONNECT_STEPS_AMOUNT)) {
                status_ = Q_TRAN(&QGprs_connecting);
            }
            /* @(/1/8/23/1/7/5/4/1/1/1) */
            else {
                me->m_ATStep = 0;
                status_ = Q_HANDLED();
            }
            break;
        }
        /* @(/1/8/23/1/7/5/4/1/2) */
        case Q_TIMEOUT_SIG: {
            me->m_ATErrorTimes ++;
            /* @(/1/8/23/1/7/5/4/1/2/0) */
            if (me->m_ATErrorTimes >= CONNECT_ERROR_MAXTIMES) {
                //设置故障类型：网络不可达
                //SetErrType(NET_CLASS, NET_FAULT_UNREACHABLE);
                status_ = Q_TRAN(&QGprs_reseting);
            }
            /* @(/1/8/23/1/7/5/4/1/2/1) */
            else {
                status_ = Q_TRAN(&QGprs_connecting);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_disconnected);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/5) ......................................................*/
static QState QGprs_connected(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/5) */
        case Q_ENTRY_SIG: {
            me->m_NetState = NET_STATE_CONNECTED;
            GPRS_SetNetState(NET_STATE_CONNECTED);
            QTimeEvt_postEvery(&me->m_LEDTimer, &me->super, TIMEOUT_LED_CONNECTED);
            QTimeEvt_postEvery(&me->m_PingTimer, &me->super, TIMEOUT_PING);
            //QTimeEvt_postEvery(&me->m_QueryTimer, &me->super, TIMEOUT_DATAQUERY);

            /*
            //首次连接网络，发送PING包
            TaskEvt *pe = Q_NEW(TaskEvt, NEW_TASKSENDREQ_SIG);
            pe->cmd = EVS15_CMD_LOGIN; //命令字=登录
            pe->sequence = GeneratePacketSequenceNumber();
            QACTIVE_POST(me, (QEvt*)pe, (void*)0);
            */
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_LEDTimer);
            QTimeEvt_disarm(&me->m_PingTimer);
            //QTimeEvt_disarm(&me->m_QueryTimer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&QGprs_Idle);
            break;
        }
        /* @(/1/8/23/1/7/5/5/1) */
        case AT_ERROR_SIG: {
            status_ = Q_TRAN(&QGprs_connecting);
            break;
        }
        /* @(/1/8/23/1/7/5/5/2) */
        case GPRS_SERVER_CONNECTED_SIG: {
            //连接状态 = 连接上服务器
            me->m_NetState = NET_STATE_SERVERCONNECTED;
            GPRS_SetNetState(NET_STATE_SERVERCONNECTED);

            //清除“网络不可达”故障
            //ClearErrType(NET_CLASS, NET_FAULT_UNREACHABLE);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_powerNormalMode);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/5/3) ....................................................*/
static QState QGprs_TcpSending(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/5/3/0) */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&QGprs_WaitFillData);
            break;
        }
        /* @(/1/8/23/1/7/5/5/3/1) */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&QGprs_Idle);
            break;
        }
        /* @(/1/8/23/1/7/5/5/3/2) */
        case AT_SENDERROR_SIG: {
            status_ = Q_TRAN(&QGprs_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_connected);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/5/3/3) ..................................................*/
static QState QGprs_WaitFillData(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/5/3/3) */
        case Q_ENTRY_SIG: {
            /* 发送TCPIP前缀字符串[AT^SISC=...] */
            GPRS_SendTCPIPPrefix(me->m_SendDataLen);

            /* 启动应答计时器 */
            QTimeEvt_postIn(&me->m_Timer, (QActive *)me, TIMEOUT_ATTIPS);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5/3/3) */
        case Q_EXIT_SIG: {
             QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5/3/3/0) */
        case AT_FILLDATATIP_SIG: {
            status_ = Q_TRAN(&QGprs_WaitRet);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_TcpSending);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/5/3/4) ..................................................*/
static QState QGprs_WaitRet(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/5/3/4) */
        case Q_ENTRY_SIG: {
            /* 填充待发送数据内容 */
            GPRS_FillinTCPIPData(me->m_sendBuf, me->m_SendDataLen);

            /* 启动应答计时器 */
            QTimeEvt_postIn(&me->m_Timer, (QActive *)me, TIMEOUT_ATSENDRET);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5/3/4) */
        case Q_EXIT_SIG: {
             QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5/3/4/0) */
        case AT_SENDOK_SIG: {
            status_ = Q_TRAN(&QGprs_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_TcpSending);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/5/4) ....................................................*/
static QState QGprs_Idle(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/5/4) */
        case Q_ENTRY_SIG: {


            if(me->m_deferedDataReady > 0)
            {
            // static const QEvent query_Evt = {AT_DATAQUERY_SIG, 0};
            //   QACTIVE_POST(me, (QEvt*)&query_Evt, (void*)0);
                me->m_deferedDataReady --;
            }
            else
            {
            /* 空闲时检索任务并处理 */
            if (QActive_recall((QActive *)me, &me->m_requestQueue)) {
                TRACE_(GPRS_STAT, &me->super, "Send Request recalled\n");
            }
            else {
                TRACE_(GPRS_STAT, &me->super, "No deferred send requests\n");
                if(me->m_bSleepReq) //先响应休眠请求，
                {
            //        static const QEvent sleep_Evt = {SLEEP_REQ_SIG, 0};
            //        QACTIVE_POST(me, (QEvt*)&sleep_Evt, (void*)0);
                }

            }
            }

            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5/4/0) */
        case NEW_TASKSENDREQ_SIG: {
            /* 组织待发送数据内容，推入发送缓区，准备发送 */
            //me->m_SendDataLen = Protocol_FormRawFrame((TaskEvt*)e, me->m_sendBuf, FRAME_BUF_SIZE);
            me->m_SendDataLen = Protocol_FormRawFrame(Q_EVT_CAST(TaskEvt), me->m_sendBuf, FRAME_BUF_SIZE);
            status_ = Q_TRAN(&QGprs_TcpSending);
            break;
        }
        /* @(/1/8/23/1/7/5/5/4/1) */
        case GPRS_COMMINGCALL_SIG: {
            status_ = Q_TRAN(&QGprs_PhoneCalling);
            break;
        }
        /* @(/1/8/23/1/7/5/5/4/2) */
        case GPRS_COMMINGSMS_SIG: {
            status_ = Q_TRAN(&QGprs_SMSHandling);
            break;
        }
        /* @(/1/8/23/1/7/5/5/4/3) */
        case GPRS_PING_TIMEOUT_SIG: {
            #if 0
            if(me->m_NetState != NET_STATE_SERVERCONNECTED)
            {
                //登录连接超时到，发送登录包
                TaskEvt *pe = Q_NEW(TaskEvt, NEW_TASKSENDREQ_SIG);
                pe->cmd = EVS15_CMD_LOGIN; //命令字=登录
                pe->sequence = GeneratePacketSequenceNumber();
                QACTIVE_POST(me, (QEvt*)pe, (void*)0);
            }
            else
            {
                TaskEvt *pe = Q_NEW(TaskEvt, NEW_TASKSENDREQ_SIG);
                pe->cmd = EVS15_CMD_LINKMAINTAIN; //命令字=链路维护
                pe->sequence = GeneratePacketSequenceNumber();
                QACTIVE_POST(me, (QEvt*)pe, (void*)0);
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5/4/4) */
        case AT_DATAQUERY_SIG: {
            status_ = Q_TRAN(&QGprs_DataQuering);
            break;
        }
        /* @(/1/8/23/1/7/5/5/4/5) */
        case SLEEP_REQ_SIG: {
            TRACE_(QS_USER, NULL, "[GPRS] ----- PowerMgr: SLEEP -----");
            me->m_bSleepReq = 0;
            status_ = Q_TRAN(&QGprs_sleepRequest);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_connected);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/5/5) ....................................................*/
static QState QGprs_PhoneCalling(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/5/5/0) */
        case GPRS_PHONECALL_HANDLED_SIG: {
            status_ = Q_TRAN(&QGprs_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_connected);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/5/6) ....................................................*/
static QState QGprs_SMSHandling(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/5/6/0) */
        case GPRS_SMS_HANDLED_SIG: {
            status_ = Q_TRAN(&QGprs_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_connected);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/5/5/7) ....................................................*/
static QState QGprs_DataQuering(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/5/5/7) */
        case Q_ENTRY_SIG: {
            //发送数据查询指令
            GPRS_doQueryData();
            /* 启动应答计时器 */
            QTimeEvt_postIn(&me->m_Timer, (QActive *)me, TIMEOUT_AT_DATAQUERYRET);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5/7) */
        case Q_EXIT_SIG: {
             QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/5/5/7/0) */
        case AT_OK_SIG: {
            //逆向提取TCP包
            GPRS_doTakeTCPPacketData();
            status_ = Q_TRAN(&QGprs_Idle);
            break;
        }
        /* @(/1/8/23/1/7/5/5/7/1) */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&QGprs_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_connected);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/7/6) ........................................................*/
static QState QGprs_sleepRequest(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/7/6) */
        case Q_ENTRY_SIG: {
            //进入休眠命令
            TRACE_(QS_USER, NULL, "[GPRS] Enable MG323 Module entering into Sleep mode...");
            GPRS_RequestSleep();
            QTimeEvt_postIn(&me->m_Timer, &me->super, TIMEOUT_ATACK);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/6) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/7/6/0) */
        case AT_OK_SIG: {
            TRACE_(QS_USER, NULL, "[GPRS] Sleep mode is Done.");
            status_ = Q_TRAN(&QGprs_powerSaveMode);
            break;
        }
        /* @(/1/8/23/1/7/6/1) */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&QGprs_sleepRequest);
            break;
        }
        /* @(/1/8/23/1/7/6/2) */
        case AT_ERROR_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_polling);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/1/8) ..........................................................*/
static QState QGprs_reseting(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/1/8) */
        case Q_ENTRY_SIG: {
            //模块上电
            GPIO_ResetBits(GPIOA,GPIOA_CDMA_CTRL_);
            //先管脚拉低
            //GPIO_ResetBits(GPIOA, GPIOA_GPRS_PWRKEY_);
            //低电平拉低1000ms
            QTimeEvt_postIn(&me->m_Timer, &me->super, TIMEOUT_RESETBEFORE_TICKS);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/8) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->m_Timer);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/1/8/0) */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&QGprs_startup);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_serving);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/2) ............................................................*/
static QState QGprs_powerSaveMode(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/2) */
        case Q_ENTRY_SIG: {
            SetSysSleepState(MODULE_SLEEP_STATE_GPRS);//设置模块睡眠态标志
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/8/23/2/0) */
        case WAKEUP_REQ_SIG: {
            TRACE_(QS_USER, NULL, "[GPRS] ----- PowerMgr: WAKEUP -----");
            ClearSysSleepState(MODULE_SLEEP_STATE_GPRS);//清除模块休眠态
            status_ = Q_TRAN(&QGprs_reseting);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/2/1) ..........................................................*/
static QState QGprs_sleep(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/2/1/0) */
        case GPRS_COMMINGSMS_SIG: {
            status_ = Q_TRAN(&QGprs_sleep_SMSHandling);
            break;
        }
        /* @(/1/8/23/2/1/1) */
        case GPRS_COMMINGCALL_SIG: {
            status_ = Q_TRAN(&QGprs_sleep_PhoneCalling);
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_powerSaveMode);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/2/2) ..........................................................*/
static QState QGprs_sleep_SMSHandling(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/2/2/0) */
        case GPRS_SMS_HANDLED_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_powerSaveMode);
            break;
        }
    }
    return status_;
}
/* @(/1/8/23/2/3) ..........................................................*/
static QState QGprs_sleep_PhoneCalling(QGprs * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/8/23/2/3/0) */
        case GPRS_PHONECALL_HANDLED_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QGprs_powerSaveMode);
            break;
        }
    }
    return status_;
}


